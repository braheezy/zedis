const std = @import("std");

const max_msg_size = @import("root.zig").max_msg_size;

pub const Conn = @This();

fd: std.posix.socket_t,
// application's intention, for the event loop
want_read: bool = false,
want_write: bool = false,
want_close: bool = false,
// buffered input and output
// data to be parsed by the application
incoming: std.ArrayList(u8),
// responses generated by the application
outgoing: std.ArrayList(u8),

pub fn init(allocator: std.mem.Allocator, fd: std.posix.socket_t) !*Conn {
    std.debug.print("init conn w/ fd: {d}\n", .{fd});
    const conn = try allocator.create(Conn);
    conn.* = Conn{
        .fd = fd,
        .incoming = try std.ArrayList(u8).initCapacity(allocator, 1024),
        .outgoing = try std.ArrayList(u8).initCapacity(allocator, 1024),
    };
    return conn;
}

pub fn deinit(self: *Conn, allocator: std.mem.Allocator) void {
    self.incoming.deinit();
    self.outgoing.deinit();
    allocator.destroy(self);
}

// process 1 request if there is enough data
pub fn oneRequest(self: *Conn) !bool {
    // Protocol: message header
    if (self.incoming.items.len < 4) {
        // want read
        return false;
    }

    const msg_len = std.mem.readInt(u32, self.incoming.items[0..4], .little);
    if (msg_len > max_msg_size) {
        // protocol error
        self.want_close = true;
        return error.MessageTooLong;
    }

    // Protocol: message body
    if (4 + msg_len > self.incoming.items.len) {
        // want read
        return false;
    }

    // request body
    const request = self.incoming.items[4 .. 4 + msg_len];

    std.log.info("client says: len: {d}, data: {s}", .{ request.len, request[0..@min(request.len, 100)] });

    // Process the parsed message.
    // generate the response (echo)
    try self.outgoing.appendSlice(&std.mem.toBytes(msg_len));
    try self.outgoing.appendSlice(request);

    // Remove the message from incoming
    self.incoming.replaceRangeAssumeCapacity(0, msg_len + 4, &.{});

    return true;
}
